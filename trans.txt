以下のようなプログラムを考えます。sttyによってcr/lfなどが混乱する通信路を使って、byte-transparentなTCPトンネルを提供します
- 変換
    - データのうち特定のバイト値にあるものをエスケープする
    - 変換方法1
        - uuencode/uudecodeによって変換する
    - 変換方法2
        - エンコード側: 0x0d, 0x0a, 0x1c, 0x7f, 0x5cがあったら、0x5cの後にそのバイトを16進数2桁のアスキーコードで出力する
        - デコード側: 0x5cが来たら、その後の2バイトを16進アスキーと見なし、元のバイトを復元する
- 送信側
    - 指定されたTCPポートでlistenし、接続があったらacceptする
    - TCPポートとの入出力を変換し、標準入出力へつなぐ
- 受信側
    - 指定されたTCPポートへ接続する
    - TCPポートとの入出力を変換し、標準入出力へつなぐ
- TCPポートとの入出力は、forkによって2つのプロセスで実装してもよい
- 送信/受信の別、TCPポート番号、変換方法はコマンド行オプションで指定する

このようなプログラムをCで書いてください。
エンコード/デコード部分は単体テストも書いてください。

- systemするオプションをつけてください
    - ポートに転送する標準入出力を外部コマンドに接続できるようにしてください
    - 外部コマンドはexecveするのではなく、systemのようにシェル経由がよいです
    - 標準エラー出力はそのまま、現在のstderrに出力でよいです

- 動作モードのエイリアスとしてto、fromを追加してください。toはconnectする側、fromがlistenする側です
- --hostのデフォルト値を `127.0.0.1` としてください

- recvは、ポートに新しいconnectionが来るたびに、新しくacceptしたソケットに対してコマンドを起動するようにしてください


- デバッグのため、トラフィックをファイルに16進ダンプする機能を作成してください。以下いずれも、オプション引数としてファイル名を与えます。readしたデータの処理が完了した時点でfflushしてください
    - --log-port-stdio (-lps) ポート→標準入出力またはコマンド方向で、エンコード前と後を両方出力
    - --log-stdio-port (-lsp) 標準入出力またはコマンド→ポート方向で、デコード前と後を両方出力
    - 16進ダンプは、1バイトを2桁の16進数で出力し、空白で区切ってください。一度のreadまたはwriteの単位で改行してください
    - エンコード前のダンプはプレフィクスとして `toenc:`、エンコード後のダンプは `enc-d:` をつけてください
    - デコード前のダンプはプレフィクスとして `todec:`、デコード後のダンプは `dec-d:` をつけてください
    - ソケットまたは標準入出力でEOFを検出したら、それもログに書いてください

以下のように修正してください
- 標準入力 → ソケット方向でデコードし、ソケット → 標準出力方向でエンコードします
- コマンドの出力 → ソケット方向でデコードし、ソケット → コマンドの入力方向でエンコードします

- O_NONBLOCKとselectを使って、200ms以内にソケットまたは標準入力からの入力がない場合は、そこまでに入力されたものを送信するようにしてください

重複コードが多いので、まとめてください
- commandがあるときとないときの処理のうち、まとめられるものはまとめる
- socketと標準入出力のやりとりで、受信してencode/decodeして送信する構造は同じなので、まとめる

深刻な問題が発覚しました。修正をお願いします
- 標準入力からBUFFER_SIZE分だけ取得した場合、エスケープシーケンス `\xx` の途中にバッファの終端が来てしまうことがあります
- escape_decode_dataでは、データ末尾がエスケープシーケンスの途中の場合(最大2バイト)、その分はデコード出力に含めず、「データがnバイト残っている」という状態を報告する必要があります。デコーダを利用する側のコードは、残った「途中かもしれないバイト」を次回の入力の先頭に付加する必要があります
- uudecode_dataでも同様に、行の途中までしか渡されていない可能性があります
- この問題はエンコーダ側には存在しません
- test_encode.cでは、この「バッファ境界」問題もテストするように修正してください


- selectで入力をタイムアウトつきで待っている部分を、pollとO_NONBLOCKによる方法に書きかえてください

- オプションに以下のエイリアスを追加してください
    - `--ll` :  `--log-prefix l --lps log_lps.log --lsp log_lsp.log` と同じ意味
    - `--lr` :  `--log-prefix r --lps log_rps.log --lsp log_rsp.log` と同じ意味

process_data_streamからデコード前のバッファ内容をhex_dump_to_fileにダンプするとき、remaining_bytesの分が考りょされていません。デコードが完了してから出力し、remaining_bytesの分は出力しないようにしてください。残した分は次回のループで出力されるはずです

- --delay (-d) オプションを追加します。-dの引数は整数で秒数を表わします
    - fromモードのとき、ポートをacceptしてから、handle_connectionを実行するまでに指定された時間だけ待ちます
    - toモードのとき、ポートにconnectしてから、handle_connectionを実行するまでに指定された時間だけ待ちます

- log_fileがNULLでなければ、時刻とプレフィクスをつけてメッセージを出力するという処理が何度もくり返されています。この処理を関数に切り出してください

- network.c 67行目の if (bytes_read == 0) のthen節とelse節は似ているので、まとめて関数にしてください

- ファイルディスクリプタをノンブロッキングモードに設定する処理をread_with_timeoutで都度行っていますが、これはprocess_data_stream開始時に一度だけやればよいです。元に戻す必要はありません
