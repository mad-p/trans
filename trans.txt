以下のようなプログラムを考えます。sttyによってcr/lfなどが混乱する通信路を使って、byte-transparentなTCPトンネルを提供します
- 変換
    - データのうち特定のバイト値にあるものをエスケープする
    - 変換方法1
        - uuencode/uudecodeによって変換する
    - 変換方法2
        - エンコード側: 0x0d, 0x0a, 0x1c, 0x7f, 0x5cがあったら、0x5cの後にそのバイトを16進数2桁のアスキーコードで出力する
        - デコード側: 0x5cが来たら、その後の2バイトを16進アスキーと見なし、元のバイトを復元する
- 送信側
    - 指定されたTCPポートでlistenし、接続があったらacceptする
    - TCPポートとの入出力を変換し、標準入出力へつなぐ
- 受信側
    - 指定されたTCPポートへ接続する
    - TCPポートとの入出力を変換し、標準入出力へつなぐ
- TCPポートとの入出力は、forkによって2つのプロセスで実装してもよい
- 送信/受信の別、TCPポート番号、変換方法はコマンド行オプションで指定する

このようなプログラムをCで書いてください。
エンコード/デコード部分は単体テストも書いてください。

- systemするオプションをつけてください
    - ポートに転送する標準入出力を外部コマンドに接続できるようにしてください
    - 外部コマンドはexecveするのではなく、systemのようにシェル経由がよいです
    - 標準エラー出力はそのまま、現在のstderrに出力でよいです

- 動作モードのエイリアスとしてto、fromを追加してください。toはconnectする側、fromがlistenする側です
- --hostのデフォルト値を `127.0.0.1` としてください

- recvは、ポートに新しいconnectionが来るたびに、新しくacceptしたソケットに対してコマンドを起動するようにしてください


- デバッグのため、トラフィックをファイルに16進ダンプする機能を作成してください。以下いずれも、オプション引数としてファイル名を与えます。readしたデータの処理が完了した時点でfflushしてください
    - --log-port-stdio (-lps) ポート→標準入出力またはコマンド方向で、エンコード前と後を両方出力
    - --log-stdio-port (-lsp) 標準入出力またはコマンド→ポート方向で、デコード前と後を両方出力
    - 16進ダンプは、1バイトを2桁の16進数で出力し、空白で区切ってください。一度のreadまたはwriteの単位で改行してください
    - エンコード前のダンプはプレフィクスとして `toenc:`、エンコード後のダンプは `enc-d:` をつけてください
    - デコード前のダンプはプレフィクスとして `todec:`、デコード後のダンプは `dec-d:` をつけてください
    - ソケットまたは標準入出力でEOFを検出したら、それもログに書いてください

以下のように修正してください
- 標準入力 → ソケット方向でデコードし、ソケット → 標準出力方向でエンコードします
- コマンドの出力 → ソケット方向でデコードし、ソケット → コマンドの入力方向でエンコードします

- O_NONBLOCKとselectを使って、200ms以内にソケットまたは標準入力からの入力がない場合は、そこまでに入力されたものを送信するようにしてください
